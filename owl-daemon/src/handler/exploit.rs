use chrono::{DateTime, Utc};
use db;
use db::models::*;
use db::schema::*;
use diesel;
use diesel::prelude::*;
use diesel::PgConnection;
use digest::Input;
use error::Error;
use exploit::ExploitError;
use exploit::TargetInfo;
use futures::Future;
use owl_rpc::model::exploit::*;
use owl_rpc::model::FileEntry;
use sha3::{Digest, Sha3_256};
use DaemonResource;

pub fn list_exploit(
    resource: &DaemonResource,
    params: ExploitListParams,
) -> Result<Vec<ExploitData>, Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;
    let show_all = params.show_all;
    let filter_targets = params.filter_targets;

    let mut query = exploits::table.inner_join(services::table).into_boxed();

    if !filter_targets.is_empty() {
        query = query.filter(services::name.eq_any(filter_targets));
    }

    if show_all {
        query = query.filter(services::enabled.eq(true));
    }

    let result = query
        .load::<(Exploit, Service)>(con)?
        .into_iter()
        .map(|(exploit, service)| {
            Ok(ExploitData {
                name: exploit.name,
                description: exploit.description,
                target_service: service.name,
                enabled: exploit.enabled,
                max_retries: exploit
                    .max_retries
                    .unwrap_or(resource.config.exploit_config.default_retries),
                timeout: exploit
                    .timeout
                    .unwrap_or(resource.config.exploit_config.default_timeout),
                skip_auth: exploit.skip_auth,
                last_modified_time: exploit.last_modified_time,
            })
        })
        .collect::<Result<Vec<_>, Error>>()?;
    Ok(result)
}

pub fn edit_exploit(resource: &DaemonResource, params: ExploitEditParams) -> Result<(), Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;

    match params {
        ExploitEditParams::Add {
            description: param_description,
            target_service: param_target_service,
            max_retries: param_max_retries,
            timeout: param_timeout,
            skip_auth: param_skip_auth,
            file_entries: param_file_entries,
        } => con.transaction::<(), Error, _>(|| {
            let service = services::table
                .filter(services::name.eq(param_target_service))
                .first::<Service>(con)?;

            let exploit_hash = {
                let mut hasher = Sha3_256::default();
                let first_file_content = &param_file_entries[0].data;

                hasher.process(first_file_content);
                hasher.result()
            };
            let mut hash_print = format!("{:x}", exploit_hash);
            hash_print.truncate(8);
            let exploit_name = format!("exploit-{}-{}", service.name, hash_print);

            let inserted_exploit = diesel::insert_into(exploits::table)
                .values(ExploitInsertable {
                    service_id: service.id,
                    name: exploit_name.clone(),
                    description: param_description,
                    enabled: true,
                    max_retries: param_max_retries,
                    timeout: param_timeout,
                    skip_auth: param_skip_auth,
                    deleted: false,
                })
                .get_result::<Exploit>(con)?;

            for file_entry in &param_file_entries {
                diesel::insert_into(exploit_attachments::table)
                    .values(ExploitAttachmentInsertable {
                        exploit_id: inserted_exploit.id,
                        name: file_entry.name.clone(),
                        data: file_entry.data.clone(),
                    })
                    .execute(con)?;
            }

            resource
                .exploit_manager
                .install_exploit(exploit_name, param_file_entries.iter())?;

            add_to_task_queue(resource, &inserted_exploit)?;

            Ok(())
        }),
        ExploitEditParams::Delete {
            name: ref param_name,
        } => {
            let rows = diesel::update(exploits::table.filter(exploits::name.eq(param_name)))
                .set(ExploitChangeset {
                    name: None,
                    service_id: None,
                    description: None,
                    enabled: None,
                    max_retries: None,
                    timeout: None,
                    skip_auth: None,
                    deleted: Some(true),
                })
                .execute(con)?;

            if rows == 0 {
                Err(Error::Message(format!("Exploit {} not found", param_name)))
            } else {
                Ok(())
            }
        },
        ExploitEditParams::Update {
            name: param_name,
            description: param_description,
            target_service: param_service_name,
            enabled: param_enabled,
            max_retries: param_max_retries,
            timeout: param_timeout,
            skip_auth: param_skip_auth,
        } => {
            let service_id = match param_service_name {
                Some(name) => Some(
                    services::table
                        .filter(services::name.eq(name))
                        .first::<Service>(con)?
                        .id,
                ),
                None => None,
            };

            // TODO: Change service variant name on service change

            let rows = diesel::update(exploits::table.filter(exploits::name.eq(&param_name)))
                .set(ExploitChangeset {
                    service_id,
                    name: None,
                    description: param_description,
                    enabled: param_enabled,
                    max_retries: param_max_retries,
                    timeout: param_timeout,
                    skip_auth: param_skip_auth,
                    deleted: None,
                })
                .execute(con)?;

            if rows == 0 {
                Err(Error::Message(format!("Exploit {} not found", param_name)))
            } else {
                Ok(())
            }
            // TODO: Add to exploit task queue
        },
    }
}

pub fn download_exploit(
    resource: &DaemonResource,
    params: ExploitDownloadParams,
) -> Result<ExploitAttachmentData, Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;
    let exploit_name = params.name;

    let exploit = exploits::table
        .filter(exploits::name.eq(exploit_name))
        .first::<Exploit>(con)?;

    let exploit_attachments = exploit_attachments::table
        .filter(exploit_attachments::exploit_id.eq(exploit.id))
        .load::<ExploitAttachment>(con)?;

    let result = ExploitAttachmentData {
        file_entries: exploit_attachments
            .into_iter()
            .map(|x| FileEntry {
                name: x.name,
                data: x.data,
            })
            .collect(),
    };
    Ok(result)
}

fn create_exploit_task(
    con: &PgConnection,
    exploit: &Exploit,
    service_provider_id: i32,
    default_retries: i32,
) -> Result<ExploitTask, Error> {
    Ok(diesel::insert_into(exploit_tasks::table)
        .values(ExploitTaskInsertable {
            exploit_id: exploit.id,
            service_provider_id,
            retries: exploit.max_retries.unwrap_or(default_retries),
            status: ExploitStatus::Pending,
            message: String::new(),
        })
        .get_result::<ExploitTask>(con)?)
}

fn active_target(con: &PgConnection, service_id: i32) -> Result<Vec<(TargetInfo, i32)>, Error> {
    Ok(service_providers::table
        .inner_join(teams::table)
        .inner_join(service_variants::table.inner_join(services::table))
        .filter(services::id.eq(service_id))
        .order_by((
            service_variants::service_id,
            service_providers::team_id,
            service_providers::published_time.desc(),
        ))
        .distinct_on((service_variants::service_id, service_providers::team_id))
        .select((
            service_providers::connection_string,
            services::name,
            teams::name,
            service_providers::id,
        ))
        .load::<(String, String, String, i32)>(con)?
        .into_iter()
        .map(|x| {
            (
                TargetInfo {
                    connection_string: x.0,
                    service_name: x.1,
                    target_team: x.2,
                },
                x.3,
            )
        })
        .collect())
}

fn add_to_task_queue(resource: &DaemonResource, exploit: &Exploit) -> Result<(), Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;

    // TODO: exclude failing exploits
    let _exploit_task_targets = exploit_targets::table
        .inner_join(service_variants::table)
        .filter(exploit_targets::exploit_id.eq(exploit.id))
        .filter(service_variants::service_id.eq(exploit.service_id))
        .load::<(ExploitTarget, ServiceVariant)>(con)?;

    // TODO: only load exploit name
    let exploit_attachments = exploit_attachments::table
        .filter(exploit_attachments::id.eq(exploit.id))
        .load::<ExploitAttachment>(con)?;

    for (target_info, service_provider_id) in active_target(con, exploit.service_id)? {
        let exploit_task = create_exploit_task(
            con,
            exploit,
            service_provider_id,
            resource.config.exploit_config.default_retries,
        )?;

        let db_pool = resource.db_pool.clone();
        let exploit_task_id = exploit_task.id;
        resource.task_executor.spawn(
            resource
                .exploit_manager
                .exploit_future(
                    resource.db_pool.clone(),
                    exploit.name.clone(),
                    &exploit_attachments[0].name,
                    target_info,
                    move |db_pool, (exploit_status, exploit_message)| {
                        diesel::update(
                            exploit_tasks::table.filter(exploit_tasks::id.eq(exploit_task_id)),
                        ).set((
                            exploit_tasks::status.eq(exploit_status),
                            exploit_tasks::message.eq(exploit_message),
                        ))
                            .execute(&*db_pool.get()?)?;

                        Ok(())
                    },
                )
                .then(move |result| {
                    if let Ok(con) = db_pool.get() {
                        let con = &*con;
                        let (exploit_status, exploit_message) = result.unwrap_or_else(|err| {
                            if let Error::ExploitError(err) = err {
                                match err {
                                    ExploitError::ExploitProcessError(err) => {
                                        (ExploitStatus::ExploitProcessError, err.to_string())
                                    },
                                    ExploitError::ExploitReturnCodeNotZero {
                                        return_code,
                                        stderr,
                                    } => (
                                        ExploitStatus::ExploitReturnCodeNotZero,
                                        format!("code {:?}: {}", return_code, stderr),
                                    ),
                                    ExploitError::AuthProcessError(err) => {
                                        (ExploitStatus::AuthProcessError, err.to_string())
                                    },
                                    ExploitError::AuthReturnCodeNotZero {
                                        return_code,
                                        stderr,
                                    } => (
                                        ExploitStatus::AuthReturnCodeNotZero,
                                        format!("code {:?}: {}", return_code, stderr),
                                    ),
                                    ExploitError::WrongFlag(flag) => {
                                        (ExploitStatus::WrongFlag, flag)
                                    },
                                }
                            } else {
                                (ExploitStatus::UnknownFailure, err.to_string())
                            }
                        });

                        diesel::update(
                            exploit_tasks::table.filter(exploit_tasks::id.eq(exploit_task_id)),
                        ).set((
                            exploit_tasks::status.eq(exploit_status),
                            exploit_tasks::message.eq(exploit_message),
                        ))
                            .execute(con)
                            .is_ok();
                    }

                    Ok(())
                }),
        );
    }

    Ok(())
}

pub fn run_exploit(
    resource: &DaemonResource,
    params: ExploitRunParams,
) -> Result<Option<Vec<ExploitTaskData>>, Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;

    let exploit_name = params.name;
    let wait_for_exploit = params.wait;

    let exploit = exploits::table
        .filter(exploits::name.eq(exploit_name))
        .first::<Exploit>(con)?;

    add_to_task_queue(resource, &exploit)?;

    // TODO: consider wait option
    Ok(None)
}

pub fn run_all_exploit(resource: &DaemonResource) -> Result<(), Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;

    let exploits = exploits::table
        .inner_join(services::table)
        .filter(exploits::enabled.eq(true))
        .filter(exploits::deleted.eq(false))
        .filter(services::enabled.eq(true))
        .load::<(Exploit, Service)>(con)?;

    for (exploit, _) in exploits {
        add_to_task_queue(resource, &exploit)?;
    }

    Ok(())
}

pub fn status_exploit(
    resource: &DaemonResource,
    params: ExploitStatusParams,
) -> Result<Vec<ExploitTaskData>, Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;
    let show_all = params.show_all;
    let filter_targets = params.filter_targets;
    let filter_skip_auth = params.filter_skip_auth;

    let mut query = exploit_tasks::table
        .inner_join(
            service_providers::table
                .inner_join(service_variants::table.inner_join(services::table))
                .inner_join(teams::table),
        )
        .inner_join(exploits::table)
        .into_boxed();

    if !filter_targets.is_empty() {
        query = query.filter(services::name.eq_any(filter_targets));
    }

    if let Some(skip_auth) = filter_skip_auth {
        query = query.filter(exploits::skip_auth.eq(skip_auth));
    }

    if !show_all {
        query = query.filter(services::enabled.eq(true));
    }

    Ok(query
        .select((
            exploits::name,
            teams::name,
            service_variants::name,
            exploit_tasks::retries,
            exploit_tasks::status,
            exploit_tasks::published_time,
            exploit_tasks::last_updated_time,
        ))
        .load(con)?
        .into_iter()
        .map(
            |x: (
                String,
                String,
                String,
                i32,
                db::models::ExploitStatus,
                DateTime<Utc>,
                DateTime<Utc>,
            )| ExploitTaskData {
                exploit_name: x.0,
                service_provider_name: x.1,
                service_variant_name: x.2,
                retries: x.3,
                //TODO: Add conversion
                status_message: "Unknown".to_string(),
                published_time: x.5,
                last_updated_time: x.6,
            },
        )
        .collect::<Vec<_>>())
}
