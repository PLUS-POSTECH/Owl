use chrono::{DateTime, Utc};
use db;
use db::models::*;
use db::schema::*;
use diesel;
use diesel::dsl::exists;
use diesel::prelude::*;
use diesel::select;
use diesel::PgConnection;
use digest::Input;
use error::Error;
use exploit::ExploitError;
use exploit::TargetInfo;
use futures::Future;
use owl_rpc::model::exploit::*;
use owl_rpc::model::FileEntry;
use sha3::{Digest, Sha3_256};
use DaemonResource;

pub type ExploitUpdateMessage = (ExploitStatus, String);

pub fn list_exploit(
    resource: &DaemonResource,
    params: ExploitListParams,
) -> Result<Vec<ExploitData>, Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;
    let show_all = params.show_all;
    let filter_targets = params.filter_targets;

    let mut query = exploits::table.inner_join(services::table).into_boxed();

    if !filter_targets.is_empty() {
        query = query.filter(services::name.eq_any(filter_targets));
    }

    if show_all {
        query = query.filter(services::enabled.eq(true));
    }

    let result = query
        .load::<(Exploit, Service)>(con)?
        .into_iter()
        .map(|(exploit, service)| {
            Ok(ExploitData {
                name: exploit.name,
                description: exploit.description,
                target_service: service.name,
                enabled: exploit.enabled,
                max_retries: exploit
                    .max_retries
                    .unwrap_or(resource.config.exploit_config.default_retries),
                timeout: exploit
                    .timeout
                    .unwrap_or(resource.config.exploit_config.default_timeout),
                skip_auth: exploit.skip_auth,
                last_modified_time: exploit.last_modified_time,
            })
        })
        .collect::<Result<Vec<_>, Error>>()?;
    Ok(result)
}

pub fn add_exploit(resource: &DaemonResource, params: ExploitAddParams) -> Result<String, Error> {
    match params {
        ExploitAddParams {
            description: param_description,
            target_service: param_target_service,
            max_retries: param_max_retries,
            timeout: param_timeout,
            skip_auth: param_skip_auth,
            file_entries: param_file_entries,
        } => {
            let con: &PgConnection = &*resource.db_pool.get()?;

            let inserted_exploit = con.transaction::<Exploit, Error, _>(|| {
                let service = services::table
                    .filter(services::name.eq(param_target_service))
                    .first::<Service>(con)?;

                let exploit_hash = {
                    let mut hasher = Sha3_256::default();

                    for file_entry in &param_file_entries {
                        hasher.process(&file_entry.data);
                    }

                    hasher.result()
                };
                let mut hash_print = format!("{:x}", exploit_hash);
                hash_print.truncate(8);
                let exploit_name = format!("exploit-{}-{}", service.name, hash_print);

                let inserted_exploit = diesel::insert_into(exploits::table)
                    .values(ExploitInsertable {
                        service_id: service.id,
                        name: exploit_name.clone(),
                        description: param_description,
                        enabled: true,
                        max_retries: param_max_retries,
                        timeout: param_timeout,
                        skip_auth: param_skip_auth,
                        deleted: false,
                    })
                    .get_result::<Exploit>(con)?;
                info!(target: "db", "[Exploit] Insert record: {}", &inserted_exploit.name);

                for file_entry in &param_file_entries {
                    diesel::insert_into(exploit_attachments::table)
                        .values(ExploitAttachmentInsertable {
                            exploit_id: inserted_exploit.id,
                            name: file_entry.name.clone(),
                            data: file_entry.data.clone(),
                        })
                        .execute(con)?;
                    info!(target: "db", "[Exploit] Insert record attachment: {} in {}", &file_entry.name, &inserted_exploit.name);
                }

                Ok(inserted_exploit)
            })?;

            resource
                .exploit_manager
                .install_exploit(&inserted_exploit.name, param_file_entries.iter())?;
            info!(target: "exploit", "Installed exploit for {}", &inserted_exploit.name);

            add_to_task_queue(resource, &inserted_exploit)?;
            info!(target: "exploit", "Scheduled exploit for {}", &inserted_exploit.name);

            Ok(inserted_exploit.name)
        },
    }
}

pub fn edit_exploit(resource: &DaemonResource, params: ExploitEditParams) -> Result<(), Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;

    match params {
        ExploitEditParams::Delete {
            name: ref param_name,
        } => {
            let rows = diesel::update(exploits::table.filter(exploits::name.eq(param_name)))
                .set(ExploitChangeset {
                    name: None,
                    service_id: None,
                    description: None,
                    enabled: None,
                    max_retries: None,
                    timeout: None,
                    skip_auth: None,
                    deleted: Some(true),
                })
                .execute(con)?;

            if rows == 0 {
                Err(Error::Message(format!("Exploit {} not found", param_name)))
            } else {
                info!(target: "db", "[Exploit] Delete record: {}", &param_name);
                Ok(())
            }
        },
        ExploitEditParams::Update {
            name: param_name,
            description: param_description,
            target_service: param_service_name,
            enabled: param_enabled,
            max_retries: param_max_retries,
            timeout: param_timeout,
            skip_auth: param_skip_auth,
        } => {
            let service_id = match param_service_name {
                Some(name) => Some(
                    services::table
                        .filter(services::name.eq(name))
                        .first::<Service>(con)?
                        .id,
                ),
                None => None,
            };

            // TODO: Change service variant name on service change

            let rows = diesel::update(exploits::table.filter(exploits::name.eq(&param_name)))
                .set(ExploitChangeset {
                    service_id,
                    name: None,
                    description: param_description,
                    enabled: param_enabled,
                    max_retries: param_max_retries,
                    timeout: param_timeout,
                    skip_auth: param_skip_auth,
                    deleted: None,
                })
                .execute(con)?;

            if rows == 0 {
                Err(Error::Message(format!("Exploit {} not found", param_name)))
            } else {
                info!(target: "db", "[Exploit] Update record: {}", &param_name);
                Ok(())
            }
            // TODO: Add to exploit task queue
        },
    }
}

pub fn failure_exploit(
    resource: &DaemonResource,
    params: ExploitFailureParams,
) -> Result<(), Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;
    let exploit_name = params.exploit_name;
    let service_variant_name = params.service_variant_name;
    let failure = params.failure;

    con.transaction::<(), Error, _>(|| {
        let exploit = exploits::table
            .filter(exploits::name.eq(&exploit_name))
            .first::<Exploit>(con)?;

        let service_variant = service_variants::table
            .filter(service_variants::name.eq(&service_variant_name))
            .first::<ServiceVariant>(con)?;

        let query = exploit_targets::table
            .filter(exploit_targets::exploit_id.eq(exploit.id))
            .filter(exploit_targets::service_variant_id.eq(service_variant.service_id));

        if select(exists(query)).get_result(con)? {
            diesel::update(query)
                .set(ExploitTargetChangeset {
                    consecutive_failure: Some(failure),
                })
                .execute(con)?;
            info!(target: "db", "[ExploitTarget] Update record: ({}, {}) -> {}", &exploit.name, &service_variant.name, failure);
        } else {
            diesel::insert_into(exploit_targets::table)
                .values(ExploitTargetInsertable {
                    exploit_id: exploit.id,
                    service_variant_id: service_variant.id,
                    consecutive_failure: failure,
                })
                .execute(con)?;
            info!(target: "db", "[ExploitTarget] Insert record: ({}, {}) -> {}", &exploit.name, &service_variant.name, failure);
        }
        Ok(())
    })
}

pub fn download_exploit(
    resource: &DaemonResource,
    params: ExploitDownloadParams,
) -> Result<ExploitAttachmentData, Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;
    let exploit_name = params.name;

    let exploit = exploits::table
        .filter(exploits::name.eq(exploit_name))
        .first::<Exploit>(con)?;

    let exploit_attachments = exploit_attachments::table
        .filter(exploit_attachments::exploit_id.eq(exploit.id))
        .load::<ExploitAttachment>(con)?;

    let result = ExploitAttachmentData {
        file_entries: exploit_attachments
            .into_iter()
            .map(|x| FileEntry {
                name: x.name,
                data: x.data,
            })
            .collect(),
    };
    Ok(result)
}

fn create_exploit_task(
    con: &PgConnection,
    exploit: &Exploit,
    service_provider_id: i32,
    default_retries: i32,
) -> Result<ExploitTask, Error> {
    Ok(diesel::insert_into(exploit_tasks::table)
        .values(ExploitTaskInsertable {
            exploit_id: exploit.id,
            service_provider_id,
            retries: exploit.max_retries.unwrap_or(default_retries),
            status: ExploitStatus::Pending,
            message: String::new(),
        })
        .get_result::<ExploitTask>(con)?)
}

fn active_target(
    con: &PgConnection,
    failure_threshold: i32,
    exploit: &Exploit,
) -> Result<Vec<(TargetInfo, i32)>, Error> {
    let target_blacklist = exploit_targets::table
        .filter(exploit_targets::exploit_id.eq(exploit.id))
        .filter(exploit_targets::consecutive_failure.gt(failure_threshold))
        .select(exploit_targets::service_variant_id)
        .load::<i32>(con)?;

    Ok(service_providers::table
        .inner_join(teams::table)
        .inner_join(service_variants::table.inner_join(services::table))
        .filter(services::id.eq(exploit.service_id))
        .filter(service_variants::id.ne_all(target_blacklist))
        .order_by((
            service_variants::service_id,
            service_providers::team_id,
            service_providers::published_time.desc(),
        ))
        .distinct_on((service_variants::service_id, service_providers::team_id))
        .select((
            service_providers::connection_string,
            services::name,
            teams::name,
            service_providers::id,
        ))
        .load::<(String, String, String, i32)>(con)?
        .into_iter()
        .map(|x| {
            (
                TargetInfo {
                    connection_string: x.0,
                    service_name: x.1,
                    target_team: x.2,
                },
                x.3,
            )
        })
        .collect())
}

fn update_exploit_status(
    con: &PgConnection,
    exploit_task_id: i32,
    update: ExploitUpdateMessage,
) -> Result<usize, Error> {
    let (exploit_status, exploit_message) = update;
    let result = diesel::update(exploit_tasks::table.filter(exploit_tasks::id.eq(exploit_task_id)))
        .set((
            exploit_tasks::status.eq(&exploit_status),
            exploit_tasks::message.eq(exploit_message),
        ))
        .execute(con)?;
    info!(target: "exploit", "[ExploitTask] Status updated: {} - {:?}", exploit_task_id, &exploit_status);
    Ok(result)
}

fn update_exploit_consecutive_failure(
    con: &PgConnection,
    exploit_task_id: i32,
    failed: bool,
) -> Result<(), Error> {
    con.transaction::<(), Error, _>(|| {
        let (exploit_task, service_provider) = exploit_tasks::table
            .filter(exploit_tasks::id.eq(exploit_task_id))
            .inner_join(service_providers::table)
            .first::<(ExploitTask, ServiceProvider)>(con)?;

        let exploit_target = exploit_targets::table
            .find((
                &exploit_task.exploit_id,
                &service_provider.service_variant_id,
            ))
            .first::<ExploitTarget>(con);

        match exploit_target {
            Ok(exploit_target) => {
                let current_failure_count = exploit_target.consecutive_failure;
                let new_failure_count = current_failure_count + 1;
                let query = diesel::update(
                    exploit_targets::table
                        .filter(exploit_targets::exploit_id.eq(exploit_task.exploit_id))
                        .filter(
                            exploit_targets::service_variant_id
                                .eq(service_provider.service_variant_id),
                        ),
                );

                if failed {
                    if current_failure_count < 0 {
                        info!(target: "exploit", "[ExploitTarget] Failure not counted: ({}, {})", exploit_task.exploit_id, service_provider.service_variant_id);
                        Ok(())
                    } else {
                        info!(target: "exploit", "[ExploitTarget] Failure count incremented: ({}, {}) - {} times", exploit_task.exploit_id, service_provider.service_variant_id, new_failure_count);
                        query
                            .set(exploit_targets::consecutive_failure.eq(new_failure_count))
                            .execute(con)?;
                        Ok(())
                    }
                } else {
                    info!(target: "exploit", "[ExploitTarget] Failure count reset: {}", exploit_task.exploit_id);
                    query
                        .set(exploit_targets::consecutive_failure.eq(0))
                        .execute(con)?;
                    Ok(())
                }
            },
            Err(_) => {
                if failed {
                    info!(target: "exploit", "[ExploitTarget] Failure count incremented: {} - {} times", exploit_task.exploit_id, 1);
                    diesel::insert_into(exploit_targets::table)
                        .values(ExploitTargetInsertable {
                            exploit_id: exploit_task.exploit_id,
                            service_variant_id: service_provider.service_variant_id,
                            consecutive_failure: 1,
                        })
                        .execute(con)?;
                    Ok(())
                } else {
                    Ok(())
                }
            },
        }
    })
}

fn add_to_task_queue(resource: &DaemonResource, exploit: &Exploit) -> Result<(), Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;
    let failure_threshold = resource.config.exploit_config.failure_threshold;

    let exploit_attachment_name = exploit_attachments::table
        .filter(exploit_attachments::exploit_id.eq(exploit.id))
        .order(exploit_attachments::id.asc())
        .select(exploit_attachments::name)
        .first::<String>(con)?;

    let timeout = exploit
        .timeout
        .unwrap_or(resource.config.exploit_config.default_timeout);

    for (target_info, service_provider_id) in active_target(con, failure_threshold, exploit)? {
        let exploit_task = create_exploit_task(
            con,
            exploit,
            service_provider_id,
            resource.config.exploit_config.default_retries,
        )?;

        let db_pool = resource.db_pool.clone();
        let exploit_task_id = exploit_task.id;
        resource.task_executor.spawn(
            resource
                .exploit_manager
                .exploit_future(
                    resource.db_pool.clone(),
                    exploit.id,
                    exploit.name.clone(),
                    &exploit_attachment_name,
                    target_info,
                    timeout,
                    move |db_pool, exploit_update_message| {
                        update_exploit_status(
                            &*db_pool.get()?,
                            exploit_task_id,
                            exploit_update_message,
                        )?;
                        Ok(())
                    },
                )
                .then(move |result| {
                    if let Ok(con) = db_pool.get() {
                        let con = &*con;
                        let (exploit_update_message, failed) = result
                            .map(|exploit_update_message| (exploit_update_message, false))
                            .unwrap_or_else(|err| {
                                info!(target: "exploit", "[ExploitTask] Failed: {}", exploit_task.id);
                                if let Error::ExploitError(err) = err {
                                    match err {
                                        ExploitError::ExploitProcessError(err) => (
                                            (ExploitStatus::ExploitProcessError, err.to_string()),
                                            true,
                                        ),
                                        ExploitError::ExploitReturnCodeNotZero {
                                            return_code,
                                            stderr,
                                        } => (
                                            (
                                                ExploitStatus::ExploitReturnCodeNotZero,
                                                format!("code {:?}: {}", return_code, stderr),
                                            ),
                                            true,
                                        ),
                                        ExploitError::ExploitTimeout(err) => (
                                            (ExploitStatus::ExploitProcessError, err.to_string()),
                                            true,
                                        ),
                                        ExploitError::AuthProcessError(err) => (
                                            (ExploitStatus::AuthProcessError, err.to_string()),
                                            false,
                                        ),
                                        ExploitError::AuthReturnCodeNotZero {
                                            return_code,
                                            stderr,
                                        } => (
                                            (
                                                ExploitStatus::AuthReturnCodeNotZero,
                                                format!("code {:?}: {}", return_code, stderr),
                                            ),
                                            false,
                                        ),
                                        ExploitError::WrongFlag(flag) => {
                                            ((ExploitStatus::WrongFlag, flag), true)
                                        },
                                    }
                                } else {
                                    ((ExploitStatus::UnknownFailure, err.to_string()), false)
                                }
                            });

                        update_exploit_status(con, exploit_task_id, exploit_update_message).is_ok();
                        update_exploit_consecutive_failure(con, exploit_task_id, failed).is_ok();
                    }

                    Ok(())
                }),
        );
        info!(target: "exploit", "[ExploitTask] Spawned: {}", exploit_task_id);
    }

    Ok(())
}

pub fn run_exploit(
    resource: &DaemonResource,
    params: ExploitRunParams,
) -> Result<Option<Vec<ExploitTaskData>>, Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;

    let exploit_name = params.name;
    let _wait_for_exploit = params.wait;

    let exploit = exploits::table
        .filter(exploits::name.eq(exploit_name))
        .first::<Exploit>(con)?;

    add_to_task_queue(resource, &exploit)?;
    info!(target: "exploit", "[ExploitTask] Scheduled exploit for 1 available exploit");

    // TODO: consider wait option
    Ok(None)
}

pub fn run_all_exploit(resource: &DaemonResource) -> Result<(), Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;

    let exploits = exploits::table
        .inner_join(services::table)
        .filter(exploits::enabled.eq(true))
        .filter(exploits::deleted.eq(false))
        .filter(services::enabled.eq(true))
        .load::<(Exploit, Service)>(con)?;

    for (exploit, _) in &exploits {
        add_to_task_queue(resource, &exploit)?;
    }
    info!(target: "exploit", "[ExploitTask] Scheduled exploit for {} available exploit", exploits.len());

    Ok(())
}

pub fn status_exploit(
    resource: &DaemonResource,
    params: ExploitStatusParams,
) -> Result<Vec<ExploitTaskData>, Error> {
    let con: &PgConnection = &*resource.db_pool.get()?;

    let mut query = exploit_tasks::table
        .inner_join(
            service_providers::table
                .inner_join(service_variants::table.inner_join(services::table))
                .inner_join(teams::table),
        )
        .inner_join(exploits::table)
        // TODO: correctly use limit and order_by
        .order_by(
            exploit_tasks::published_time.desc()
        )
        .limit(200)
        .into_boxed();

    if !params.filter_targets.is_empty() {
        query = query.filter(services::name.eq_any(params.filter_targets));
    }

    if let Some(skip_auth) = params.filter_skip_auth {
        query = query.filter(exploits::skip_auth.eq(skip_auth));
    }

    if let Some(exploit_name) = params.filter_exploit {
        query = query.filter(exploits::name.eq(exploit_name));
    }

    if !params.show_all {
        query = query.filter(services::enabled.eq(true));
    }

    Ok(query
        .select((
            exploits::name,
            teams::name,
            service_variants::name,
            exploit_tasks::retries,
            exploit_tasks::status,
            exploit_tasks::message,
            exploit_tasks::published_time,
            exploit_tasks::last_updated_time,
        ))
        .load(con)?
        .into_iter()
        .rev()
        .map(
            |x: (
                String,
                String,
                String,
                i32,
                db::models::ExploitStatus,
                String,
                DateTime<Utc>,
                DateTime<Utc>,
            )| ExploitTaskData {
                exploit_name: x.0,
                service_provider_name: x.1,
                service_variant_name: x.2,
                retries: x.3,
                status_enum: format!("{:?}", x.4),
                status_message: x.5,
                published_time: x.6,
                last_updated_time: x.7,
            },
        )
        .collect::<Vec<_>>())
}
