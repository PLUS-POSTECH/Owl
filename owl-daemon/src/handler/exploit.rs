use chrono::{DateTime, Utc};
use db::models::*;
use db::schema::*;
use db::DbPool;
use diesel;
use diesel::prelude::*;
use diesel::result::Error as DieselError;
use diesel::PgConnection;
use digest::Input;
use error::Error;
use owl_exploit::ExploitRunner;
use owl_rpc::model::exploit::*;
use owl_rpc::model::FileEntry;
use sha3::{Digest, Sha3_256};

pub fn list_exploit(db_pool: DbPool, params: ExploitListParams) -> Result<Vec<ExploitData>, Error> {
    let con: &PgConnection = &*db_pool.get()?;
    let show_all = params.show_all;
    let filter_targets = params.filter_targets;

    let mut query = exploits::table.inner_join(services::table).into_boxed();

    if !filter_targets.is_empty() {
        query = query.filter(services::name.eq_any(filter_targets));
    }

    if show_all {
        query = query.filter(services::enabled.eq(true));
    }

    let result = query
        .load::<(Exploit, Service)>(con)?
        .into_iter()
        .map(|(exploit, service)| {
            Ok(ExploitData {
                name: exploit.name,
                description: exploit.description,
                target_service: service.name,
                enabled: exploit.enabled,
                max_retries: match exploit.max_retries {
                    Some(max_retries) => max_retries,
                    None => 10, // TODO: Use config to set default
                },
                timeout: match exploit.timeout {
                    Some(timeout) => timeout,
                    None => 60, // TODO: Use config to set default
                },
                skip_auth: exploit.skip_auth,
                last_modified_time: exploit.last_modified_time,
            })
        })
        .collect::<Result<Vec<_>, Error>>()?;
    Ok(result)
}

pub fn edit_exploit(db_pool: DbPool, params: ExploitEditParams) -> Result<(), Error> {
    let con: &PgConnection = &*db_pool.get()?;

    match params {
        ExploitEditParams::Add {
            description: param_description,
            target_service: param_target_service,
            max_retries: param_max_retries,
            timeout: param_timeout,
            skip_auth: param_skip_auth,
            file_entries: param_file_entries,
        } => con.transaction::<(), Error, _>(|| {
            let service = services::table
                .filter(services::name.eq(param_target_service))
                .first::<Service>(con)?;

            let exploit_hash = {
                let mut hasher = Sha3_256::default();
                let first_file_content = &param_file_entries[0].data;

                hasher.process(first_file_content);
                hasher.result()
            };
            let mut hash_print = format!("{:x}", exploit_hash);
            hash_print.truncate(8);

            let inserted_exploit = diesel::insert_into(exploits::table)
                .values(ExploitInsertable {
                    service_id: service.id,
                    name: format!("exploit-{}-{}", service.name, hash_print),
                    description: param_description,
                    enabled: false,
                    max_retries: param_max_retries,
                    timeout: param_timeout,
                    skip_auth: param_skip_auth,
                    deleted: false,
                })
                .get_result::<Exploit>(con)?;

            for file_entry in param_file_entries {
                diesel::insert_into(exploit_attachments::table)
                    .values(ExploitAttachmentInsertable {
                        exploit_id: inserted_exploit.id,
                        name: file_entry.name,
                        data: file_entry.data,
                    })
                    .execute(con)?;
            }
            Ok(())
            // TODO: Add to exploit task queue
        }),
        ExploitEditParams::Delete {
            name: ref param_name,
        } => {
            let rows = diesel::update(exploits::table.filter(exploits::name.eq(param_name)))
                .set(ExploitChangeset {
                    name: None,
                    service_id: None,
                    description: None,
                    enabled: None,
                    max_retries: None,
                    timeout: None,
                    skip_auth: None,
                    deleted: Some(true),
                })
                .execute(con)?;

            if rows == 0 {
                Err(Error::Message(format!("Exploit {} not found", param_name)))
            } else {
                Ok(())
            }
        },
        ExploitEditParams::Update {
            name: param_name,
            description: param_description,
            target_service: param_service_name,
            enabled: param_enabled,
            max_retries: param_max_retries,
            timeout: param_timeout,
            skip_auth: param_skip_auth,
        } => {
            let service_id = match param_service_name {
                Some(name) => Some(
                    services::table
                        .filter(services::name.eq(name))
                        .first::<Service>(con)?
                        .id,
                ),
                None => None,
            };

            // TODO: Change service variant name on service change

            let rows = diesel::update(exploits::table.filter(exploits::name.eq(&param_name)))
                .set(ExploitChangeset {
                    service_id,
                    name: None,
                    description: param_description,
                    enabled: param_enabled,
                    max_retries: param_max_retries,
                    timeout: param_timeout,
                    skip_auth: param_skip_auth,
                    deleted: None,
                })
                .execute(con)?;

            if rows == 0 {
                Err(Error::Message(format!("Exploit {} not found", param_name)))
            } else {
                Ok(())
            }
            // TODO: Add to exploit task queue
        },
    }
}

pub fn download_exploit(
    db_pool: DbPool,
    params: ExploitDownloadParams,
) -> Result<ExploitAttachmentData, Error> {
    let con: &PgConnection = &*db_pool.get()?;
    let exploit_name = params.name;

    let exploit = exploits::table
        .filter(exploits::name.eq(exploit_name))
        .first::<Exploit>(con)?;

    let exploit_attachments = exploit_attachments::table
        .filter(exploit_attachments::exploit_id.eq(exploit.id))
        .load::<ExploitAttachment>(con)?;

    let result = ExploitAttachmentData {
        file_entries: exploit_attachments
            .into_iter()
            .map(|x| FileEntry {
                name: x.name,
                data: x.data,
            })
            .collect(),
    };
    Ok(result)
}

pub fn run_exploit(
    db_pool: DbPool,
    params: ExploitRunParams,
) -> Result<Option<Vec<ExploitTaskData>>, Error> {
    let con: &PgConnection = &*db_pool.get()?;
    // Add exploit runner

    let exploit_name = params.name;
    let wait_for_exploit = params.wait;

    let exploit = exploits::table
        .filter(exploits::name.eq(exploit_name))
        .first::<Exploit>(con)?;

    let exploit_attachments = exploit_attachments::table
        .filter(exploit_attachments::exploit_id.eq(exploit.id))
        .load::<ExploitAttachment>(con)?;

    // Do Outer Join
    let exploit_task_targets = exploit_targets::table
        .inner_join(service_variants::table)
        .filter(exploit_targets::exploit_id.eq(exploit.id))
        .filter(service_variants::service_id.eq(exploit.service_id))
        .load::<(ExploitTarget, ServiceVariant)>(con)?;

    Ok(None)
}
