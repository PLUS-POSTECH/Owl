use std::borrow::Cow;
use std::fs;
use std::fs::File;
use std::io;
use std::io::prelude::*;
use std::path::{Path, PathBuf};
use std::process::Command;

use error::Error;
use futures::prelude::*;
use shell_escape::escape;
use tokio_process::CommandExt;

pub enum ExploitStatus {
    Pending,
    Running,
    Authenticating(String),
    SuccessFlag(String),
    DuplicateFlag(String),
    AuthenticationSkipped,
}

#[derive(Debug, Fail)]
pub enum ExploitError {
    // e.g. killed by signal
    #[fail(display = "process error: {}", _0)]
    ProcessError(#[cause] io::Error),
    // return code is not 0
    #[fail(display = "process returned {:?}: {}", return_code, stderr)]
    ReturnCodeNotZero {
        return_code: Option<i32>,
        stderr: String,
    },
    #[fail(display = "auth error: {}", _0)]
    AuthError(String),
}

pub struct TargetInfo<'a> {
    pub connection_string: &'a str,
    pub service_name: &'a str,
    pub target_team: &'a str,
}

pub struct ExploitRunner {
    root_dir: PathBuf,
    auth_command: String,
}

#[cfg(unix)]
fn give_execute_permission(file: &mut File) -> Result<(), io::Error> {
    use std::os::unix::fs::PermissionsExt;
    let mut permissions = file.metadata()?.permissions();
    permissions.set_mode(0o744);
    Ok(())
}

#[cfg(windows)]
fn give_execute_permission(_file: &mut File) -> Result<(), io::Error> {
    Ok(())
}

fn shell_command_runner(full_command: &str) -> Command {
    let command_parser = if cfg!(target_os = "windows") {
        "cmd"
    } else {
        "sh"
    };

    let escaped_command = escape(full_command.into());
    let command_args = if cfg!(target_os = "windows") {
        ["/C", &escaped_command]
    } else {
        ["-c", &escaped_command]
    };

    let mut command = Command::new(command_parser);
    command.args(&command_args);
    command
}

impl ExploitRunner {
    pub fn new<T: Into<PathBuf>>(root_dir: T, auth_command: String) -> ExploitRunner {
        let root_dir: PathBuf = root_dir.into();

        if !root_dir.exists() {
            // TODO: graceful handling
            fs::create_dir_all(&root_dir).expect("cannot create the directory for exploits");
        }

        ExploitRunner {
            root_dir,
            auth_command,
        }
    }

    pub fn exploit_dir<T: AsRef<Path>>(&self, name: T) -> PathBuf {
        self.root_dir.join(name)
    }

    pub fn install_exploit<T: AsRef<Path>>(
        &self,
        exploit_name: T,
        vec: &Vec<(&str, &Vec<u8>)>,
    ) -> Result<(), Error> {
        fs::create_dir(self.exploit_dir(&exploit_name))?;
        for (file_name, data) in vec {
            let path = self.exploit_dir(&exploit_name).join(file_name);
            let mut file = File::create(path)?;
            file.write_all(data)?;
            give_execute_permission(&mut file)?;
        }
        Ok(())
    }

    pub fn exploit_future<F, T: AsRef<Path>>(
        &self,
        exploit_name: T,
        entry_file: &str,
        target_info: TargetInfo,
        update: F,
    ) -> impl IntoFuture<Item = ExploitStatus, Error = Error>
    where
        F: Fn(ExploitStatus) -> Result<(), Error> + 'static,
    {
        let full_command = format!(
            "{} {} {} {}",
            escape(entry_file.into()),
            escape(target_info.connection_string.into()),
            escape(target_info.service_name.into()),
            escape(target_info.target_team.into()),
        );

        let auth_directory = self.exploit_dir(exploit_name);
        let auth_command = self.auth_command.clone();

        let exploit_future = Box::new(
            update(ExploitStatus::Running)
            .into_future()
            // run exploit
            .and_then(move |_| shell_command_runner(&full_command)
                .current_dir(auth_directory)
                .output_async()
                .map_err(|e| Error::ExploitError(ExploitError::ProcessError(e))))
            .and_then(|output| if output.status.success() {
                Ok(String::from_utf8_lossy(&output.stdout).into_owned())
            } else {
                Err(Error::ExploitError(ExploitError::ReturnCodeNotZero {
                    return_code: output.status.code(),
                    stderr: String::from_utf8_lossy(&output.stderr).into(),
                }))
            }),
        );

        let auth_future = move |flag: String| {
            // run authenticator
            let auth_command = format!(
                "{} {}",
                escape(auth_command.into()),
                escape(Cow::Borrowed(&flag)),
            );

            Box::new(
                update(ExploitStatus::Authenticating(flag.clone()))
                    .into_future()
                    .and_then(move |_| {
                        shell_command_runner(&auth_command)
                            .output_async()
                            .map_err(|e| Error::ExploitError(ExploitError::ProcessError(e)))
                    })
                    .and_then(move |output| {
                        if output.status.success() {
                            // TODO: check flag skipping
                            let auth_output = String::from_utf8_lossy(&output.stdout)
                                .trim()
                                .to_lowercase();
                            match auth_output.as_str() {
                                "ok" => Ok(ExploitStatus::SuccessFlag(flag.clone())),
                                "duplicate" => Ok(ExploitStatus::DuplicateFlag(flag.clone())),
                                _ => {
                                    Err(Error::ExploitError(ExploitError::AuthError(flag.clone())))
                                },
                            }
                        } else {
                            Err(Error::ExploitError(ExploitError::ReturnCodeNotZero {
                                return_code: output.status.code(),
                                stderr: String::from_utf8_lossy(&output.stderr).into(),
                            }))
                        }
                    }),
            )
        };

        exploit_future.and_then(auth_future)
    }
}
