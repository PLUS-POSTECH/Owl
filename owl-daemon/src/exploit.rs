use std::borrow::Cow;
use std::fs;
use std::fs::File;
use std::io;
use std::io::prelude::*;
use std::path::{Path, PathBuf};
use std::process::Command;

use db::models::ExploitStatus;
use db::DbPool;
use error::Error;
use futures::prelude::*;
use owl_rpc::model::FileEntry;
use shell_escape::escape;
use tokio_process::CommandExt;

type ExploitUpdate = (ExploitStatus, String);

#[derive(Debug, Fail)]
pub enum ExploitError {
    // e.g. killed by signal
    #[fail(display = "process error: {}", _0)]
    ExploitProcessError(#[cause] io::Error),
    // return code is not 0
    #[fail(display = "process returned {:?}: {}", return_code, stderr)]
    ExploitReturnCodeNotZero {
        return_code: Option<i32>,
        stderr: String,
    },
    #[fail(display = "process error: {}", _0)]
    AuthProcessError(#[cause] io::Error),
    // return code is not 0
    #[fail(display = "process returned {:?}: {}", return_code, stderr)]
    AuthReturnCodeNotZero {
        return_code: Option<i32>,
        stderr: String,
    },
    #[fail(display = "auth error: {}", _0)]
    WrongFlag(String),
}

pub struct TargetInfo {
    pub connection_string: String,
    pub service_name: String,
    pub target_team: String,
}

#[derive(Clone)]
pub struct ExploitManager {
    root_dir: PathBuf,
    auth_command: String,
}

#[cfg(unix)]
fn give_execute_permission(file: &mut File) -> Result<(), io::Error> {
    use std::os::unix::fs::PermissionsExt;
    let mut permissions = file.metadata()?.permissions();
    permissions.set_mode(0o744);
    Ok(())
}

#[cfg(windows)]
fn give_execute_permission(_file: &mut File) -> Result<(), io::Error> {
    Ok(())
}

fn shell_command_runner(full_command: &str) -> Command {
    let command_parser = if cfg!(target_os = "windows") {
        "cmd"
    } else {
        "sh"
    };

    let command_args = if cfg!(target_os = "windows") {
        ["/C", full_command]
    } else {
        ["-c", full_command]
    };

    let mut command = Command::new(command_parser);
    command.args(&command_args);
    command
}

impl ExploitManager {
    pub fn new<T: Into<PathBuf>>(root_dir: T, auth_command: String) -> ExploitManager {
        let root_dir: PathBuf = root_dir.into();

        if !root_dir.exists() {
            // TODO: graceful handling
            fs::create_dir_all(&root_dir).expect("cannot create the directory for exploits");
        }

        ExploitManager {
            root_dir,
            auth_command,
        }
    }

    pub fn exploit_dir<T: AsRef<Path>>(&self, name: T) -> PathBuf {
        self.root_dir.join(name)
    }

    pub fn install_exploit<'a, T: AsRef<Path>>(
        &self,
        exploit_name: T,
        iter: impl Iterator<Item = &'a FileEntry>,
    ) -> Result<(), Error> {
        fs::create_dir(self.exploit_dir(&exploit_name))?;
        for file_entry in iter {
            let path = self.exploit_dir(&exploit_name).join(&file_entry.name);
            let mut file = File::create(path)?;
            file.write_all(&file_entry.data)?;
            give_execute_permission(&mut file)?;
        }
        Ok(())
    }

    pub fn exploit_future<F, T: AsRef<Path>>(
        &self,
        db_pool: DbPool,
        exploit_name: T,
        entry_file: &str,
        target_info: TargetInfo,
        update: F,
    ) -> impl Future<Item = ExploitUpdate, Error = Error>
    where
        F: Fn(DbPool, ExploitUpdate) -> Result<(), Error> + 'static,
    {
        let full_command = if cfg!(target_os = "windows") {
            format!(
                "{} {} {} {}",
                escape(entry_file.into()),
                escape(target_info.connection_string.into()),
                escape(target_info.service_name.into()),
                escape(target_info.target_team.into()),
            )
        } else {
            format!(
                "./{} {} {} {}",
                escape(entry_file.into()),
                escape(target_info.connection_string.into()),
                escape(target_info.service_name.into()),
                escape(target_info.target_team.into()),
            )
        };

        let exploit_directory = self.exploit_dir(exploit_name);
        let auth_command = self.auth_command.clone();

        let exploit_future = Box::new(
            update(db_pool.clone(), (ExploitStatus::Running, String::new()))
            .into_future()
            // run exploit
            .and_then(move |_| shell_command_runner(&full_command)
                .current_dir(exploit_directory)
                .output_async()
                .map_err(|e| Error::ExploitError(ExploitError::ExploitProcessError(e))))
            .and_then(|output| if output.status.success() {
                // TODO: correctly escape the flag
                Ok(String::from_utf8_lossy(&output.stdout).into_owned().lines().next().unwrap_or("").to_string())
            } else {
                Err(Error::ExploitError(ExploitError::ExploitReturnCodeNotZero {
                    return_code: output.status.code(),
                    stderr: String::from_utf8_lossy(&output.stderr).into(),
                }))
            }),
        );

        let auth_future = move |flag: String| {
            // run authenticator
            let auth_command = format!("{} {}", auth_command, escape(Cow::Borrowed(&flag)),);

            Box::new(
                update(
                    db_pool.clone(),
                    (ExploitStatus::Authenticating, flag.clone()),
                ).into_future()
                    .and_then(move |_| {
                        shell_command_runner(&auth_command)
                            .output_async()
                            .map_err(|e| Error::ExploitError(ExploitError::AuthProcessError(e)))
                    })
                    .and_then(move |output| {
                        if output.status.success() {
                            // TODO: check flag skipping
                            let auth_output = String::from_utf8_lossy(&output.stdout)
                                .trim()
                                .to_lowercase();
                            match auth_output.as_str() {
                                "ok" => Ok((ExploitStatus::SuccessFlag, flag.clone())),
                                "duplicate" => Ok((ExploitStatus::DuplicateFlag, flag.clone())),
                                _ => {
                                    Err(Error::ExploitError(ExploitError::WrongFlag(flag.clone())))
                                },
                            }
                        } else {
                            Err(Error::ExploitError(ExploitError::AuthReturnCodeNotZero {
                                return_code: output.status.code(),
                                stderr: String::from_utf8_lossy(&output.stderr).into(),
                            }))
                        }
                    }),
            )
        };

        exploit_future.and_then(auth_future)
    }
}
