use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;

use clap::{App, AppSettings, Arg, ArgMatches, SubCommand};
use error::Error;
use owl_rpc::model::exploit::*;
use owl_rpc::model::FileEntry;
use SharedParam;

fn parse_numeric_or_none(value: &str) -> Result<Option<i32>, Error> {
    Ok(match value {
        "none" => None,
        value => Some(value.parse::<i32>()?),
    })
}

fn parse_numeric_or_disable(value: &str) -> Result<i32, Error> {
    Ok(match value {
        "disable" => -1,
        value => value.parse::<i32>()?,
    })
}

pub fn exploit_command() -> App<'static, 'static> {
    SubCommand::with_name("exploit")
        .about("User defined exploit management")
        .setting(AppSettings::SubcommandRequired)
        .subcommands(vec![
            SubCommand::with_name("submit")
                .about("add new user defined exploit")
                .args(&[
                    Arg::from_usage("<file>... 'binary file representing exploit'"),
                    Arg::from_usage(
                        "-t, --target <service_name> 'target service to make exploit run on'",
                    ),
                    Arg::from_usage(
                        "-d, --description [description] 'description of exploit'",
                    ),
                    Arg::from_usage(
                        "-R, --max-retries [max_retries] 'maximum retry settings for exploit'",
                    ),
                    Arg::from_usage(
                        "-T, --timeout [timeout] 'timeout settings of exploit'",
                    ),
                    Arg::from_usage(
                        "-A, --skip-auth [skip_auth] 'marks the exploit process if it will skip authentication step'",
                    ).possible_values(&["true", "false"]),
                ]),
            SubCommand::with_name("delete")
                .about("delete specified exploit")
                .args(&[Arg::from_usage(
                    "<name> 'name of the exploit to delete'",
                )]),
            SubCommand::with_name("enable")
                .about("enable specified exploit to execute in scheduled run")
                .args(&[Arg::from_usage(
                    "<name> 'name of the exploit to enable'",
                )]),
            SubCommand::with_name("disable")
                .about("disable specified exploit to prevent scheduled run")
                .args(&[Arg::from_usage(
                    "<name> 'name of the exploit to disable'",
                )]),
            SubCommand::with_name("update")
                .about("update exploit metadata")
                .args(&[
                    Arg::from_usage("<name> 'name of the exploit to update'"),
                    Arg::from_usage(
                        "-t, --target [service_name] 'updates target service to make exploit run on'",
                    ),
                    Arg::from_usage(
                        "-d, --description [description] 'updates description of exploit'",
                    ),
                    Arg::from_usage(
                        "-R, --max-retries [retries] 'updates maximum retry settings for exploit'",
                    ),
                    Arg::from_usage(
                        "-T, --timeout [timeout] 'updates timeout settings of exploit'",
                    ),
                    Arg::from_usage(
                        "-A, --skip-auth [skip_auth] 'updates the exploit process if it will skip authentication step'",
                    ).possible_values(&["true", "false"]),
                ]),
            SubCommand::with_name("list")
                .about("list available exploits")
                .args(&[
                    Arg::from_usage("-a, --all 'shows disabled exploit too'"),
                    Arg::from_usage("-T, --filter-target... [service_name] 'filters exploit by target service'"),
                ]),
            SubCommand::with_name("download")
                .about("download specified exploit")
                .args(&[
                    Arg::from_usage("<name> 'name of the exploit to download'"),
                ]),
            SubCommand::with_name("failure")
                .about("update failure value for specific exploit target (admin)")
                .args(&[
                    Arg::from_usage("<exploit_name> 'name of the exploit to modify'"),
                    Arg::from_usage("<service_variant_name> 'name of the targeting service variant'"),
                    Arg::from_usage("<failure> 'failure value to set'"),
                ]),
            SubCommand::with_name("run-all")
                .about("trigger scheduled exploit process (admin)"),
            SubCommand::with_name("run")
                .about("trigger specific exploit to run")
                .args(&[
                    Arg::from_usage("<name> 'name of the exploit to run'"),
                    Arg::from_usage("-w, --wait 'wait until the exploit is done and show the result'"),
                ]),
            SubCommand::with_name("status")
                .about("show recent status of the exploit processes")
                .args(&[
                    Arg::from_usage("-a, --all 'shows disabled exploit too'"),
                    Arg::from_usage("-d, --detail 'shows status detail'"),
                    Arg::from_usage("-T, --filter-target... [service_name] 'filter exploits by target service'"),
                    Arg::from_usage("-x, --filter-exploit [exploit_name] 'shows results of specific exploit'"),
                    Arg::from_usage(
                        "-A, --filter-skip-auth 'filter exploits by authentication settings'"
                    ).possible_values(&["true", "false"]),
                ]),
        ])
}

pub fn exploit_match(matches: &ArgMatches, shared_param: SharedParam) -> Result<String, Error> {
    match matches.subcommand() {
        ("submit", Some(matches)) => {
            let file_entries = matches
                .values_of("file")
                .unwrap()
                .map(|param_file_name| {
                    let mut file = File::open(param_file_name)?;
                    let mut data = Vec::new();
                    file.read_to_end(&mut data)?;

                    let file_name = Path::new(param_file_name).file_name();
                    match file_name {
                        Some(file_name) => Ok(FileEntry {
                            name: file_name.to_string_lossy().to_string(),
                            data,
                        }),
                        None => Err(Error::FileNotFoundError(param_file_name.to_string())),
                    }
                })
                .collect::<Result<Vec<_>, Error>>()?;

            let exploit_name = shared_param.client.add_exploit(
                shared_param.token,
                ExploitAddParams {
                    description: matches.value_of("description").unwrap_or("").to_string(),
                    target_service: matches.value_of("target").unwrap().to_string(),
                    max_retries: parse_numeric_or_none(
                        matches.value_of("max-retries").unwrap_or("none"),
                    )?,
                    timeout: parse_numeric_or_none(matches.value_of("timeout").unwrap_or("none"))?,
                    skip_auth: match matches.value_of("skip-auth") {
                        Some("true") => true,
                        _ => false,
                    },
                    file_entries,
                },
            )?;

            Ok(format!("Exploit successfully added: {}", exploit_name))
        },

        ("delete", Some(matches)) => {
            shared_param.client.edit_exploit(
                shared_param.token,
                ExploitEditParams::Delete {
                    name: matches.value_of("name").unwrap().to_string(),
                },
            )?;

            Ok("Variant successfully deleted".to_string())
        },

        ("enable", Some(matches)) => {
            shared_param.client.edit_exploit(
                shared_param.token,
                ExploitEditParams::Update {
                    name: matches.value_of("name").unwrap().to_string(),
                    description: None,
                    target_service: None,
                    enabled: Some(true),
                    max_retries: None,
                    timeout: None,
                    skip_auth: None,
                },
            )?;

            Ok("Exploit successfully enabled".to_string())
        },

        ("disable", Some(matches)) => {
            shared_param.client.edit_exploit(
                shared_param.token,
                ExploitEditParams::Update {
                    name: matches.value_of("name").unwrap().to_string(),
                    description: None,
                    target_service: None,
                    enabled: Some(false),
                    max_retries: None,
                    timeout: None,
                    skip_auth: None,
                },
            )?;

            Ok("Exploit successfully disabled".to_string())
        },

        ("update", Some(matches)) => {
            shared_param.client.edit_exploit(
                shared_param.token,
                ExploitEditParams::Update {
                    name: matches.value_of("name").unwrap().to_string(),
                    description: matches.value_of("description").map(ToString::to_string),
                    target_service: matches.value_of("target").map(ToString::to_string),
                    enabled: None,
                    max_retries: if matches.is_present("max-retries") {
                        Some(parse_numeric_or_none(
                            matches.value_of("max-retries").unwrap(),
                        )?)
                    } else {
                        None
                    },
                    timeout: if matches.is_present("timeout") {
                        Some(parse_numeric_or_none(matches.value_of("timeout").unwrap())?)
                    } else {
                        None
                    },
                    skip_auth: match matches.value_of("skip-auth") {
                        Some("true") => Some(true),
                        Some("false") => Some(false),
                        _ => None,
                    },
                },
            )?;

            Ok("Exploit successfully enabled".to_string())
        },

        ("list", Some(matches)) => {
            let exploits = shared_param.client.list_exploit(
                shared_param.token,
                ExploitListParams {
                    show_all: matches.is_present("all"),
                    filter_targets: matches
                        .values_of("filter-target")
                        .map(|values| -> Vec<_> { values.map(ToString::to_string).collect() })
                        .unwrap_or(Vec::new()),
                },
            )?;

            if exploits.is_empty() {
                Ok("No exploit registered".to_string())
            } else {
                Ok(exploits
                    .into_iter()
                    .map(|exploit| {
                        format!(
                            "- {:10} | {:10} | {:10} | {:10} | {:10} | {:10} | {:10} | {}",
                            exploit.name,
                            exploit.description,
                            exploit.target_service,
                            exploit.enabled,
                            exploit.max_retries,
                            exploit.timeout,
                            exploit.skip_auth,
                            exploit.last_modified_time,
                        )
                    })
                    .collect::<Vec<_>>()
                    .join("\n"))
            }
        },

        ("download", Some(matches)) => {
            println!("Downloading files...");
            let file_entries = shared_param
                .client
                .download_exploit(
                    shared_param.token,
                    ExploitDownloadParams {
                        name: matches.value_of("name").unwrap().to_string(),
                    },
                )?
                .file_entries;

            for file_entry in &file_entries {
                let file_name = &file_entry.name;
                let file_contents = &file_entry.data;

                println!("Writing {}...", file_name);
                let mut file = File::create(file_name)?;
                file.write_all(&file_contents[..])?;
            }

            Ok("Exploit successfully downloaded".to_string())
        },

        ("failure", Some(matches)) => {
            shared_param.client.failure_exploit(
                shared_param.token,
                ExploitFailureParams {
                    exploit_name: matches.value_of("exploit_name").unwrap().to_string(),
                    service_variant_name: matches
                        .value_of("service_variant_name")
                        .unwrap()
                        .to_string(),
                    failure: parse_numeric_or_disable(
                        matches.value_of("failure").unwrap_or("disable"),
                    )?,
                },
            )?;

            Ok("Exploit failure successfully updated".to_string())
        },

        ("run-all", Some(_matches)) => {
            shared_param.client.run_all_exploit(shared_param.token)?;

            Ok("Exploit run successfully scheduled".to_string())
        },

        ("run", Some(matches)) => match shared_param.client.run_exploit(
            shared_param.token,
            ExploitRunParams {
                name: matches.value_of("name").unwrap().to_string(),
                wait: matches.is_present("wait"),
            },
        )? {
            Some(exploit_status_data_list) => Ok(exploit_status_data_list
                .into_iter()
                .map(|exploit_status_data| {
                    format!(
                        "- {:10} | {:10} | {:10} | {:10} | {:10?} | {:10} | {}",
                        exploit_status_data.exploit_name,
                        exploit_status_data.service_provider_name,
                        exploit_status_data.service_variant_name,
                        exploit_status_data.retries,
                        exploit_status_data.status_message,
                        exploit_status_data.published_time,
                        exploit_status_data.last_updated_time,
                    )
                })
                .collect::<Vec<_>>()
                .join("\n")),
            None => Ok("Exploit run successfully triggered".to_string()),
        },

        ("status", Some(matches)) => {
            let exploit_status_data_list = shared_param.client.status_exploit(
                shared_param.token,
                ExploitStatusParams {
                    show_all: matches.is_present("all"),
                    filter_targets: matches
                        .values_of("filter-target")
                        .map(|values| -> Vec<_> { values.map(ToString::to_string).collect() })
                        .unwrap_or(Vec::new()),
                    filter_skip_auth: match matches.value_of("filter-skip-auth") {
                        Some("true") => Some(true),
                        Some("false") => Some(false),
                        _ => None,
                    },
                    filter_exploit: matches.value_of("filter-exploit").map(ToString::to_string),
                },
            )?;
            Ok(exploit_status_data_list
                .into_iter()
                .map(|exploit_status_data| {
                    if matches.is_present("detail") {
                        format!(
                            "- {} | {:20} | {} | {:25} | {} | {}\n{}\n",
                            exploit_status_data.exploit_name,
                            exploit_status_data.service_provider_name,
                            exploit_status_data.service_variant_name,
                            exploit_status_data.status_enum,
                            exploit_status_data.published_time,
                            exploit_status_data.last_updated_time,
                            exploit_status_data.status_message,
                        )
                    } else {
                        format!(
                            "- {} | {:20} | {} | {:25} | {} | {}",
                            exploit_status_data.exploit_name,
                            exploit_status_data.service_provider_name,
                            exploit_status_data.service_variant_name,
                            exploit_status_data.status_enum,
                            exploit_status_data.published_time,
                            exploit_status_data.last_updated_time,
                        )
                    }
                })
                .collect::<Vec<_>>()
                .join("\n"))
        },

        _ => Err(Error::InvalidSubcommand),
    }
}
