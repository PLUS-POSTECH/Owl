use std::fs::File;
use std::io::{Read, Write};

use clap::{App, AppSettings, Arg, ArgMatches, SubCommand};
use error::Error;
use owl_rpc::model::exploit::*;
use owl_rpc::model::FileEntry;
use SharedParam;

pub fn exploit_command() -> App<'static, 'static> {
    SubCommand::with_name("exploit")
        .about("User defined exploit management")
        .setting(AppSettings::SubcommandRequired)
        .subcommands(vec![
            SubCommand::with_name("submit")
                .about("Add new user defined exploit")
                .args(&[
                    Arg::from_usage("<file>... 'Binary file representing exploit'"),
                    Arg::from_usage(
                        "-t, --target [service_name] 'Target service to make exploit run on'",
                    ),
                    Arg::from_usage(
                        "-d, --description [description] 'Description of exploit'",
                    ),
                    Arg::from_usage(
                        "-R, --max-retries [max_retries] 'Maximum retry settings for exploit'",
                    ),
                    Arg::from_usage(
                        "-T, --timeout [timeout] 'Timeout settings of exploit'",
                    ),
                    Arg::from_usage(
                        "-A, --skip-auth [skip_auth] 'Marks the exploit process if it will skip authentication step'",
                    ).possible_values(&["true", "false"]),
                ]),
            SubCommand::with_name("delete")
                .about("Delete specified exploit")
                .args(&[Arg::from_usage(
                    "<name> 'Name of the exploit to delete'",
                )]),
            SubCommand::with_name("enable")
                .about("Enable specified exploit to execute in scheduled run")
                .args(&[Arg::from_usage(
                    "<name> 'Name of the exploit to enable'",
                )]),
            SubCommand::with_name("disable")
                .about("Disable specified exploit to prevent scheduled run")
                .args(&[Arg::from_usage(
                    "<name> 'Name of the exploit to disable'",
                )]),
            SubCommand::with_name("update")
                .about("Update exploit metadata")
                .args(&[
                    Arg::from_usage("<name> 'Name of the exploit to update'"),
                    Arg::from_usage(
                        "-t, --target [service_name] 'Updates target service to make exploit run on'",
                    ),
                    Arg::from_usage(
                        "-d, --description [description] 'Updates description of exploit'",
                    ),
                    Arg::from_usage(
                        "-R, --max-retries [retries] 'Updates maximum retry settings for exploit'",
                    ),
                    Arg::from_usage(
                        "-T, --timeout [timeout] 'Updates timeout settings of exploit'",
                    ),
                    Arg::from_usage(
                        "-A, --skip-auth [skip_auth] 'Updates the exploit process if it will skip authentication step'",
                    ).possible_values(&["true", "false"]),
                ]),
            SubCommand::with_name("list")
                .about("List available exploits")
                .args(&[
                    Arg::from_usage("-a, --all 'Shows disabled exploit also'"),
                    Arg::from_usage("-T, --filter-target... [service_name] 'Filters exploit by target service'"),
                ]),
            SubCommand::with_name("download")
                .about("Download specified exploit")
                .args(&[
                    Arg::from_usage("<name> 'Name of the exploit to download'"),
                ]),
            SubCommand::with_name("run-all")
                .about("Trigger scheduled exploit process (admin)"),
            SubCommand::with_name("run")
                .about("Trigger specific exploit to run")
                .args(&[
                    Arg::from_usage("<name> 'Name of the exploit to run'"),
                    Arg::from_usage("-w, --wait 'Wait until the exploit is done and show result'"),
                ]),
            SubCommand::with_name("status")
                .about("View status of the exploit processes")
                .args(&[
                    Arg::from_usage("-a, --all 'Shows disabled exploit also'"),
                    Arg::from_usage("-T, --filter-target... [service_name] 'Filters exploit by target service'"),
                    Arg::from_usage(
                        "-A, --filter-skip-auth 'Filters exploit which doesn't authenticate'"
                    ).possible_values(&["true", "false"]),
                ]),
        ])
}

pub fn exploit_match(matches: &ArgMatches, shared_param: SharedParam) -> Result<String, Error> {
    match matches.subcommand() {
        ("submit", Some(matches)) => {
            let file_entries = matches
                .values_of("file")
                .unwrap()
                .map(|filename| {
                    let mut file = File::open(filename)?;
                    let mut data = Vec::new();
                    file.read_to_end(&mut data)?;

                    Ok(FileEntry {
                        name: filename.to_string(),
                        data,
                    })
                })
                .collect::<Result<Vec<_>, Error>>()?;

            shared_param.client.edit_exploit(
                shared_param.token,
                ExploitEditParams::Add {
                    description: matches.value_of("description").unwrap().to_string(),
                    target_service: matches.value_of("target").unwrap().to_string(),
                    max_retries: if matches.is_present("max-retries")
                        && matches.value_of("max-retries").unwrap() != "none"
                    {
                        matches.value_of("max-retries").unwrap().parse::<i32>()?
                    } else {
                        None
                    },
                    timeout: if matches.is_present("timeout")
                        && matches.value_of("timeout").unwrap() != "none"
                    {
                        matches.value_of("timeout").unwrap().parse::<i32>()?
                    } else {
                        None
                    },
                    skip_auth: if matches.is_present("skip-auth")
                        && matches.value_of("skip-auth").unwrap() != "true"
                    {
                        false
                    } else {
                        true
                    },
                    file_entries,
                },
            )?;

            Ok("Exploit successfully added".to_string())
        },

        ("delete", Some(matches)) => {
            shared_param.client.edit_exploit(
                shared_param.token,
                ExploitEditParams::Delete {
                    name: matches.value_of("name").unwrap().to_string(),
                },
            )?;

            Ok("Variant successfully deleted".to_string())
        },

        ("enable", Some(matches)) => {
            shared_param.client.edit_exploit(
                shared_param.token,
                ExploitEditParams::Update {
                    name: matches.value_of("name").unwrap().to_string(),
                    description: None,
                    target_service: None,
                    enabled: Some(true),
                    max_retries: None,
                    timeout: None,
                    skip_auth: None,
                },
            )?;

            Ok("Exploit successfully enabled".to_string())
        },

        ("disable", Some(matches)) => {
            shared_param.client.edit_exploit(
                shared_param.token,
                ExploitEditParams::Update {
                    name: matches.value_of("name").unwrap().to_string(),
                    description: None,
                    target_service: None,
                    enabled: Some(false),
                    max_retries: None,
                    timeout: None,
                    skip_auth: None,
                },
            )?;

            Ok("Exploit successfully disabled".to_string())
        },

        ("update", Some(matches)) => {
            shared_param.client.edit_exploit(
                shared_param.token,
                ExploitEditParams::Update {
                    name: matches.value_of("name").unwrap().to_string(),
                    description: matches.value_of("description").map(ToString::to_string),
                    target_service: matches.value_of("target").map(ToString::to_string),
                    enabled: None,
                    max_retries: if matches.is_present("max-retries") {
                        if matches.value_of("max-retries").unwrap() != "none" {
                            Some(matches.value_of("max-retries").unwrap().parse::<i32>()?)
                        } else {
                            Some(None)
                        }
                    } else {
                        None
                    },
                    timeout: if matches.is_present("timeout") {
                        if matches.value_of("timeout").unwrap() != "none" {
                            Some(matches.value_of("timeout").unwrap().parse::<i32>()?)
                        } else {
                            Some(None)
                        }
                    } else {
                        None
                    },
                    skip_auth: match matches.value_of("skip-auth") {
                        Some("true") => Some(Some(true)),
                        Some("false") => Some(Some(false)),
                        Some("none") => Some(None),
                        _ => None,
                    },
                },
            )?;

            Ok("Exploit successfully enabled".to_string())
        },

        ("list", Some(matches)) => {
            let exploits = shared_param.client.list_exploit(
                shared_param.token,
                ExploitListParams {
                    show_all: matches.is_present("all"),
                    filter_targets: matches
                        .values_of("filter-target")
                        .unwrap()
                        .map(ToString::to_string)
                        .collect(),
                },
            )?;

            if exploits.is_empty() {
                Ok("No exploit registered".to_string())
            } else {
                Ok(exploits
                    .into_iter()
                    .map(|exploit| {
                        format!(
                            "- {:10} | {:10} | {:10} | {:10} | {:10} | {:10} | {:10} | {}",
                            exploit.name,
                            exploit.description,
                            exploit.target_service,
                            exploit.enabled,
                            exploit.max_retries,
                            exploit.timeout,
                            exploit.skip_auth,
                            exploit.last_modified_time,
                        )
                    })
                    .collect::<Vec<_>>()
                    .join("\n"))
            }
        },

        ("download", Some(matches)) => {
            println!("Downloading files...");
            let file_entries = shared_param
                .client
                .download_exploit(
                    shared_param.token,
                    ExploitDownloadParams {
                        name: matches.value_of("name").unwrap().to_string(),
                    },
                )?
                .file_entries;

            for file_entry in &file_entries {
                let file_name = &file_entry.name;
                let file_contents = &file_entry.data;

                println!("Writing {}...", file_name);
                let mut file = File::create(file_name)?;
                file.write_all(&file_contents[..])?;
            }

            Ok("Exploit successfully downloaded".to_string())
        },

        ("run-all", Some(_matches)) => {
            shared_param.client.run_all_exploit(shared_param.token)?;

            Ok("Exploit run successfully scheduled".to_string())
        },

        ("run", Some(_matches)) => match shared_param.client.run_exploit(
            shared_param.token,
            ExploitRunParams {
                name: matches.value_of("name").unwrap().to_string(),
                wait: matches.is_present("wait"),
            },
        )? {
            Some(exploit_status_data_list) => Ok(exploit_status_data_list
                .into_iter()
                .map(|exploit_status_data| {
                    format!(
                        "- {:10} | {:10} | {:10} | {:10} | {:10} | {:10} | {}",
                        exploit_status_data.exploit_name,
                        exploit_status_data.service_provider_name,
                        exploit_status_data.service_variant_name,
                        exploit_status_data.retries,
                        exploit_status_data.status,
                        exploit_status_data.published_time,
                        exploit_status_data.last_updated_time,
                    )
                })
                .collect::<Vec<_>>()
                .join("\n")),
            None => Ok("Exploit run successfully triggered".to_string()),
        },

        ("status", Some(_matches)) => {
            let exploit_status_data_list = shared_param.client.run_exploit(
                shared_param.token,
                ExploitStatusParams {
                    show_all: matches.is_present("all"),
                    filter_targets: matches
                        .values_of("filter-target")
                        .unwrap()
                        .map(ToString::to_string)
                        .collect(),
                    filter_skip_auth: match matches.value_of("filter-skip-auth") {
                        Some("true") => Some(true),
                        Some("false") => Some(false),
                        _ => None,
                    },
                },
            )?;
            Ok(exploit_status_data_list
                .into_iter()
                .map(|exploit_status_data| {
                    format!(
                        "- {:10} | {:10} | {:10} | {:10} | {:10} | {:10} | {}",
                        exploit_status_data.exploit_name,
                        exploit_status_data.service_provider_name,
                        exploit_status_data.service_variant_name,
                        exploit_status_data.retries,
                        exploit_status_data.status,
                        exploit_status_data.published_time,
                        exploit_status_data.last_updated_time,
                    )
                })
                .collect::<Vec<_>>()
                .join("\n"))
        },

        _ => Err(Error::InvalidSubcommand),
    }
}
