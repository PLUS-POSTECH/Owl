extern crate futures;
#[macro_use] extern crate log;
extern crate tokio;
extern crate tokio_process;

use std::io::Error;
use std::process::{Command, Output};

use futures::prelude::*;
use futures::sync::mpsc;
use tokio::runtime::TaskExecutor;
use tokio_process::CommandExt;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}

pub struct ExploitResult {

}

pub struct ExploitRunner {
    executor: TaskExecutor,
}

impl ExploitRunner {
    fn run(&self, exploit_path: String, connection_string: String, tx: mpsc::Sender<Output>) {
        self.executor.spawn(Command::new(&exploit_path)
            .env("OWL_CONNECTION_STRING", &connection_string)
            .arg(&connection_string)
            .output_async()
            .then(move |result| {
                match result {
                    Ok(output) => {
                        if let Err(error) = tx.send(output).wait() {
                            warn!("Exploit: {} @ {} callback error", &exploit_path, &connection_string);
                        }
                    },
                    Err(error) => {
                        warn!("Exploit: {} @ {} execution error, with {:?}", &exploit_path, &connection_string, error);
                    }
                }
                Ok(())
            }));
    }
}
