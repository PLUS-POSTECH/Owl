#[macro_use]
extern crate log;

extern crate futures;
extern crate tokio;
extern crate tokio_process;

use std::io::Error;
use std::process::{Command, Output};

use futures::prelude::*;
use tokio::runtime::TaskExecutor;
use tokio_process::CommandExt;

#[cfg(test)]
mod tests {
    extern crate env_logger;

    use std::io::Error;
    use std::process::Output;
    use super::ExploitRunner;
    use futures::prelude::*;
    use futures::{future, Future};
    use futures::sync::mpsc;
    use tokio::runtime::Runtime;

    #[test]
    fn test_exploit_runner_echo() {
        let _ = env_logger::try_init();
        let rt = Runtime::new().unwrap();
        let (tx, mut rx) = mpsc::channel::<Result<Output, Error>>(0);
        let exploit_runner = ExploitRunner::new(rt.executor().clone());
        exploit_runner.run("echo".to_string(), "abcd".to_string(), move |result: Result<Output, Error>| {
            tx.clone().send(result).wait().unwrap();
            Ok(())
        });

        let result = future::poll_fn(|| {
            rx.poll()
        })
        .wait().unwrap().unwrap();
        rx.close();
        rt.shutdown_on_idle().wait().unwrap();

        let output = result.unwrap();
        let stdout = String::from_utf8(output.stdout).unwrap();
        let stderr = String::from_utf8(output.stderr).unwrap();
        info!("Exit code: {}", output.status.code().unwrap());
        info!("stdout: {}", stdout);
        info!("stderr: {}", stderr);
        assert_eq!(stdout.as_str().trim(), "abcd");
    }
}

pub struct ExploitRunner {
    task_executor: TaskExecutor,
}

impl ExploitRunner {
    pub fn new(task_executor: TaskExecutor) -> ExploitRunner {
        ExploitRunner { task_executor }
    }
    pub fn run<F>(&self, exploit_command: String, connection_string: String, callback: F)
        where F: Fn(Result<Output, Error>) -> Result<(), ()> + Send + Sync + 'static {
        info!("Spawning exploit task: {}, {}", exploit_command, connection_string);
        let command_parser = if cfg!(target_os = "windows") {
            "cmd"
        } else {
            "sh"
        };

        let full_command = format!("{} {}", exploit_command, connection_string);
        let command_args = if cfg!(target_os = "windows") {
            ["/C", full_command.as_str()]
        } else {
            ["-c", full_command.as_str()]
        };
        info!("Command Parser: {}", command_parser);
        info!("Full command: {}", full_command);

        self.task_executor.spawn(Command::new(command_parser)
            .env("OWL_CONNECTION_STRING", connection_string)
            .args(&command_args)
            .output_async()
            .then(callback));
    }
}
