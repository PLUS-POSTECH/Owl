#[macro_use]
extern crate log;

extern crate futures;
extern crate tokio;
extern crate tokio_process;

use std::io::Error;
use std::process::{Command, Output};

use futures::prelude::*;
use tokio::runtime::TaskExecutor;
use tokio_process::CommandExt;

#[cfg(test)]
mod tests;

pub struct ExploitRunner {
    task_executor: TaskExecutor,
}

impl ExploitRunner {
    pub fn new(task_executor: TaskExecutor) -> ExploitRunner {
        ExploitRunner { task_executor }
    }
    pub fn run<F>(&self, exploit_command: String, connection_string: String, callback: F)
        where F: Fn(Result<Output, Error>) -> Result<(), ()> + Send + Sync + 'static {
        info!("Spawning exploit task: {}, {}", exploit_command, connection_string);
        let command_parser = if cfg!(target_os = "windows") {
            "cmd"
        } else {
            "sh"
        };

        let full_command = format!("{} {}", exploit_command, connection_string);
        let command_args = if cfg!(target_os = "windows") {
            ["/C", full_command.as_str()]
        } else {
            ["-c", full_command.as_str()]
        };
        info!("Command Parser: {}", command_parser);
        info!("Full command: {}", full_command);

        self.task_executor.spawn(Command::new(command_parser)
            .env("OWL_CONNECTION_STRING", connection_string)
            .args(&command_args)
            .output_async()
            .then(callback));
    }
}
