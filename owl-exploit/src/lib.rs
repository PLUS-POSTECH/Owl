#[macro_use]
extern crate log;

extern crate futures;
extern crate tokio;
extern crate tokio_process;

use std::io::Error;
use std::process::{Command, Output};

use futures::prelude::*;
use tokio::runtime::TaskExecutor;
use tokio_process::CommandExt;

#[cfg(test)]
mod tests {
    extern crate env_logger;

    use std::io::Error;
    use std::process::Output;
    use super::ExploitRunner;
    use futures::prelude::*;
    use futures::{future, Future};
    use futures::sync::mpsc;
    use tokio::runtime::Runtime;

    #[test]
    fn test_exploit_runner() {
        let _ = env_logger::try_init();
        let rt = Runtime::new().unwrap();
        let (tx, mut rx) = mpsc::channel::<Result<Output, Error>>(0);
        let exploit_runner = ExploitRunner::new(rt.executor().clone());
        exploit_runner.run("echo".to_string(), "abcd".to_string(), move |result: Result<Output, Error>| {
            tx.clone().send(result).wait().unwrap();
            Ok(())
        });
        let result = future::poll_fn(|| {
            rx.poll()
        })
        .wait().unwrap().unwrap();
        rx.close();
        rt.shutdown_on_idle().wait().unwrap();

        let output = result.unwrap();
        let stdout = String::from_utf8(output.stdout).unwrap();
        let stderr = String::from_utf8(output.stderr).unwrap();
        info!("Exit code: {}", output.status.code().unwrap());
        info!("stdout: {}", stdout);
        info!("stderr: {}", stderr);
    }
}

pub struct ExploitRunner {
    task_executor: TaskExecutor,
}

impl ExploitRunner {
    pub fn new(task_executor: TaskExecutor) -> ExploitRunner {
        ExploitRunner { task_executor }
    }
    pub fn run<F>(&self, exploit_path: String, connection_string: String, callback: F)
        where F: Fn(Result<Output, Error>) -> Result<(), ()> + Send + Sync + 'static {
        trace!("Spawning exploit task: {}, {}", &exploit_path, &connection_string);
        self.task_executor.spawn(Command::new(&exploit_path)
            .env("OWL_CONNECTION_STRING", &connection_string)
            .arg(&connection_string)
            .output_async()
            .then(callback));
    }
}
