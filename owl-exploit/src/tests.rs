extern crate env_logger;

use std::io::Error;
use std::process::Output;
use super::ExploitRunner;
use futures::prelude::*;
use futures::{future, Future};
use futures::sync::mpsc;
use tokio::runtime::Runtime;

fn run_exploit(command: String, connection_string: String) -> Output {
    let _ = env_logger::try_init();
    let rt = Runtime::new().unwrap();
    let (tx, mut rx) = mpsc::channel::<Result<Output, Error>>(0);
    let exploit_runner = ExploitRunner::new(rt.executor().clone());
    exploit_runner.run(command, connection_string, move |result: Result<Output, Error>| {
        tx.clone().send(result).wait().unwrap();
        Ok(())
    });

    let result = future::poll_fn(|| {
        rx.poll()
    })
    .wait().unwrap().unwrap();
    rx.close();
    rt.shutdown_on_idle().wait().unwrap();
    result.unwrap()
}

#[test]
fn test_exploit_echo() {
    let output = run_exploit("echo".to_string(), "abcd".to_string());
    let stdout = String::from_utf8(output.stdout).unwrap();
    let stderr = String::from_utf8(output.stderr).unwrap();
    info!("Exit code: {}", output.status.code().unwrap());
    info!("stdout: {}", stdout);
    info!("stderr: {}", stderr);
    assert!(output.status.success());
    assert_eq!(stdout.trim(), "abcd");
}

#[test]
fn test_exploit_invalid() {
    let output = run_exploit("some_invalid_command".to_string(), "abcd".to_string());
    info!("Exit code: {}", output.status.code().unwrap());
    assert!(!output.status.success());
}
