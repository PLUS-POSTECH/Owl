extern crate env_logger;

use std::io::Error;
use std::process::Output;

use super::ExploitRunner;
use futures::prelude::*;
use futures::sync::mpsc;
use futures::{future, Future};
use tokio::runtime::Runtime;


fn run_exploit(command: String, connection_string: String) -> Result<Output, Error> {
    let _ = env_logger::try_init();
    let rt = Runtime::new().unwrap();
    let (tx, mut rx) = mpsc::channel::<Result<Output, Error>>(0);
    let tx_clone = tx.clone();
    let exploit_runner = ExploitRunner::new(rt.executor().clone());
    exploit_runner.run(
        command,
        connection_string,
        move |result: Result<Output, Error>| {
            tx_clone.send(result).wait().expect("Cannot send result to test method");
            Ok(())
        },
    );

    let result = future::poll_fn(|| rx.poll()).wait().unwrap().unwrap();
    rx.close();
    rt.shutdown_on_idle().wait().unwrap();
    result
}

#[test]
fn test_exploit_echo() {
    let output = run_exploit("echo".to_string(), "abcd".to_string()).unwrap();
    let stdout = String::from_utf8(output.stdout).unwrap();
    let stderr = String::from_utf8(output.stderr).unwrap();
    info!("Exit code: {}", output.status.code().expect("Cannot retrieve status code from exploit runner"));
    info!("stdout: {}", stdout);
    info!("stderr: {}", stderr);
    assert!(output.status.success());
    assert_eq!(stdout.trim(), "abcd");
}

#[test]
fn test_exploit_invalid() {
    let output = run_exploit("some_invalid_command".to_string(), "abcd".to_string()).unwrap();
    info!("Exit code: {}", output.status.code().unwrap());
    assert!(!output.status.success());
}
